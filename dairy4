基于前两天多次失败的研究：
————————————————————————————————————————————————————————————————————————————————————————
第一天的选择排序问题： 1.)选择排序函数是否可以替换成其他的排序方法，通过pta的检测？       
                      2.)输入终止的方式是什么？无限循环还是说是固定次数？无限循环       
                      如何得到最后一组的结果？固定次数又该如何确定次数的具体数值？
                      
第二天的冒泡排序问题：1.)同上，另外添加一句：这些排序方法，一种排序方法是否与一种
                      程序的写法一一对应？
                      2.)已经证实在“选择排序问题”中，可以通过设置迷之“6次循环”来完
                      成输入的终止。但是为什么本次的题目不能通过这种方式结束输入？
                      3.)想要使用无限循环的时候，搜到“for(int i;cin>>i)”达到无限循环
                      的方式，但是却显示“段错误”，使用“while（scanf（“%d%d”，&a，&b））”
                      就不会造成段错误的问题，为什么？
_________________________________________________________________________________________

额外产生的问题：所谓控制k次排序的结果，次数是指的哪个次数？要知道一次完整的排序过程分为很多
次小比较与排序，难以理解（至少现在我是这样）次数的具体指代对象。
————————————————————————————————————————————————————————————————————————————————————————
此处附上两个问题的详情以及关键步骤：
=========================================================================================
输入n个数据。利用选择排序进行编程，输出第k轮排序后的数列状况。

输入格式:
每组测试包含两行，分别是整数n,k (0<=k<n<100)，以及n个原始数据。

输出格式:
输出第k轮排序后的数列结果(数据之间1个空格，尾端无多余空格)。

输入样例:
6 3
3 5 1 2 8 6
4 3
9 8 7 6
5 0
4 3 2 9 7
输出样例:
1 2 3 5 8 6
6 7 8 9
4 3 2 9 7
关键步骤：
1.使用固定次数的循环结束输入：
    for (flag = 1; flag <= 6; flag++)
2.选择排序的写法：
    for(int i=0;i<k;i++){
       	for(int j=i+1;j<n;j++){
	       	if(a[j]<a[i]){
	       		temp=a[j];
	       		a[j]=a[i];
	       		a[i]=temp;
 	       	}
	       }
       }
==========================================================================================
输入n个数据。利用冒泡排序进行编程（先排最大值），输出第k轮排序后的数列状况。

输入格式:
输出第k轮排序后的数列结果(数据之间1个空格，尾端无多余空格)。

输出格式:
请在这里描述输出格式。例如：对每一组输入，在一行中输出A+B的值。

输入样例:
6 3
3 5 1 2 8 6
4 3
9 8 7 6
5 0
4 3 2 9 7
输出样例:
1 2 3 5 6 8
6 7 8 9
4 3 2 9 7
关键步骤：
1.结束输入的方式：
    while(cin>>n>>k)
2.冒泡排序的写法：
    if (k == 0)
		{
			for (int i = 0; i < n - 1; i++)
			{
				cout << a[i] << " ";
			}
			cout << a[n - 1];
			cout << endl;
		}
		else
		{
			for (int i = 1; i <= k; i++)
			{

				for (int j = 0; j <= n - i - 1; j++)
				{
					if (a[j] > a[j + 1]) {
						temp = a[j];
						a[j] = a[j + 1];
						a[j + 1] = temp;
					}
				}
			}
